_model: tutorial
---
_slug: rueda-de-color-hsl
---
title: Rueda de color HSL
---
sort_key: 1
---
og_image: visual-abstract-hsl.png
---
abstract: El tono, la saturaci√≥n y la luminosidad son cualidades que usamos a menudo para describir los colores en nuestra vida diaria. Representemos este modelo de colores usando el m√≥dulo de Python `colorsys` y la funci√≥n Drawbot `arc()`
---
visual_abstract: visual-abstract-hsl.png
---
body:

#### text-block ####
content: Este tutorial te guiar√° a trav√©s de los detalles de una visualizaci√≥n alternativa del modelo de color RGB, llamada [Matiz, saturaci√≥n, y luminosidad (HSL)](https://en.wikipedia.org/wiki/HSL_and_HSV). Es muy utilizado en aplicaciones gr√°ficas y, a diferencia de RGB, est√° m√°s ligado a nuestra percepci√≥n. HSL (por su siglas en ingl√©s) son cualidades que usamos a menudo para describir el color en nuestra vida diaria. RGB, en cambio, es m√°s una descripci√≥n t√©cnica de c√≥mo se genera el color en una pantalla y se almacena en la memoria.
#### image ####
name: cylinder.png
----
class: small_image
#### text-block ####
content: Una caracter√≠stica peculiar del modelo HSL es la forma en que se distribuye el matiz en el espacio. De hecho, el matiz tiene una organizaci√≥n radial, los colores de cada tono est√°n dispuestos en un corte radial. En cambio, la saturaci√≥n y la luminosidad son dimensiones linea¬≠les. Podemos representar la suma de dos dimensiones lineales y una dimensi√≥n angular usando un cilindro (con un agujero longitudinal).
#### text-block ####
content: Podemos suponer que los valores que pertenecen a las dimensiones lineales fluct√∫an entre 0 y 1, mientras que la dimensi√≥n angular ‚Äìmatiz‚Äì se mueve entre 0 y 360. Esta suposici√≥n no surge de una necesidad t√©cnica ‚Äìde hecho, vamos a utilizar puntos flotantes de 0 a 1 para el matiz tambi√©n‚Äì pero creo que har√° que nuestro c√≥digo sea m√°s accesible. Aqu√≠ puedes ver c√≥mo vamos a crear nuestro factor de matiz a partir de una iteraci√≥n sobre un √°ngulo de c√≠rculo completo, ejecuta el script y verifica la salida de la consola
#### code-example ####
snippet: hueRange+es.py
----
image: 
----
diagram: 
#### text-block ####
content: Considera tambi√©n que las dos dimensiones lineales ‚Äìsaturaci√≥n y luminosidad‚Äì se pueden intercambiar en el modelo HSL 3D, por lo que nuestro programa deber√≠a poder reconocerlo. Los siguientes cilindros son representaciones v√°lidas del modelo de color HSL.
#### image ####
name: cd-roms.png
----
class: large_image
#### text-block ####
content: Pero, nuestra imagen de referencia de visualizaci√≥n es un disco bidimensional, ¬øqu√© relaci√≥n tiene con estos cilindros? El programa cortar√° el cilindro como una sierra y luego mostrar√° la cara donde se hizo el corte. Este procedimiento requerir√° una variable independiente para que el usuario decida d√≥nde cortar el cilindro.
#### image ####
name: cd-rom-saw.png
----
class: large_image
#### text-block ####
content: Comencemos a ensamblar algo de c√≥digo. En primer lugar, debemos convertir el valor HSL en RGB, porque Drawbot solo puede aceptar valores RGB o CMYK. El m√≥dulo `colorsys` de la biblioteca est√°ndar proporciona la funci√≥n perfecta para esta necesidad `hls_to_rgb(h, l, s)`.
#### code-example ####
snippet: hls_func+es.py
----
image: 
----
diagram: 
#### text-block ####
content: `hls_to_rgb()` devuelve una tupla con tres puntos flotantes que podemos usar directamente en la funci√≥n de relleno Drawbot. Esta operaci√≥n se puede lograr de dos maneras, podemos recoger cada elemento usando la sintaxis de acceso para secuencias
#### code-example ####
snippet: tuple_access+es.py
----
image: 
----
diagram: 
#### text-block ####
content: o podemos usar el [desempaquetado iterable](https://www.python.org/dev/peps/pep-3132/)
#### code-example ####
snippet: iterable_unpacking+es.py
----
image: 
----
diagram: 
#### text-block ####
content: Ahora que sabemos c√≥mo emparejar `hls_to_rgb()` con las funciones de dibujo de Drawbot, intentemos atravesar por separado las tres dimensiones diferentes del modelo de color HSL. La dimensi√≥n angular ‚Äìmatiz‚Äì se puede mostrar a trav√©s de un anillo de √≥valos llenos de diferentes matices.
#### code-example ####
snippet: hue_traverse+es.py
----
image: 
----
diagram: 
#### text-block ####
content: Las dimensiones lineales ‚Äìsaturaci√≥n y luminosidad‚Äì se pueden presentar mediante una serie de rayas. Observa la construcci√≥n condicional dentro del bucle `for`, ya es posible que el usuario cambie entre saturaci√≥n y luminosidad.
#### code-example ####
snippet: linear_traverse+es.py
----
image: 
----
diagram: 
#### text-block ####
content: Tambi√©n podr√≠amos mostrarlos a la vez, usando una estructura visual matricial
#### code-example ####
snippet: sat+lum+es.py
----
image: 
----
diagram: 
#### text-block ####
content: Si alineamos las tres salidas del script anterior usando el √°ngulo de matiz de 0 ¬∞, 120 ¬∞ y 240 ¬∞, obtendremos tres tablas de saturaci√≥n/luminosidad para los canales RGB: rojo, verde y azul.
#### image ####
name: matrix-sat-lum.png
----
class: large_image
#### image ####
name: radial.png
----
class: small_image
#### text-block ####
content: ¬øC√≥mo podemos mezclar las dimensiones linea¬≠les con la dimensi√≥n angular? Una estructura visual radial puede servir para este prop√≥sito. Podemos hacerlo usando un bucle `for` anidado ‚Äìdel ejemplo de la matriz‚Äì combinado con el anillo de √≥valos. En este ejemplo, cada anillo representa un valor de luminosidad diferente, mientras que cada segmento de √≥valos representa un valor de matiz diferente. La saturaci√≥n es constante. A continuaci√≥n, se muestra el c√≥digo utilizado para generar esta imagen.
#### code-example ####
snippet: radial+es.py
----
image: 
----
diagram: 
#### image ####
name: detail.png
----
class: small_image
#### text-block ####
content: Ya casi llegamos, pero todav√≠a tenemos que averiguar c√≥mo trazar la secuencia de anillos del ejemplo inicial. No podemos usar una pila de c√≠rculos con radio creciente porque no podemos llenar los c√≠rculos con varios colores. Pero podemos cortar los c√≠rculos en m√∫ltiples arcos ‚Äìmuy peque√±os‚Äì. Si hacemos zoom en el ejemplo inicial, podemos ver c√≥mo se organizan las diferentes trayectorias üîé
#### text-block ####
content: Drawbot proporciona un grupo de [funciones](https://www.drawbot.com/content/shapes/drawingPath.html) para dibujar trazados B√©zier en un lienzo. En este grupo destaca la funci√≥n `arco()`, la herra¬≠mienta exacta que necesitamos para solucionar este problema. La funci√≥n `arco()` debe ser adoptada por las funciones `newPath()` y `drawPath()` para poder ubicarse en el lienzo. Sus argumentos son el punto central y el radio del c√≠rculo al que pertenece el arco, m√°s los √°ngulos que definen el rango del arco y la direcci√≥n del dibujo ‚Äìen sentido horario o antihorario‚Äì.
#### image ####
name: arcs.png
----
class: large_image
#### text-block ####
content: Si combinamos muchos arcos juntos con un trazo grueso, el resultado en el lienzo se parecer√° a una dona plana, un anillo con muchos arcos coloreados con diferentes matices. Si sustituimos los √≥valos de uno de los ejemplos anteriores, podemos obtener la estructura de m√∫ltiples anillos del ejemplo inicial, solo tenemos que asegurarnos un agujero para la rosquilla.
#### image ####
name: donuts.png
----
class: large_image
#### code-example ####
snippet: donut+es.py
----
image: 
----
diagram: 
#### text-block ####
content: En este punto solo nos faltan los subt√≠tulos. Deben colocarse en el bucle `for` exterior, despu√©s de que cada parte con el mismo se haya colocado en el lienzo. Considerando la necesidad de una transformaci√≥n matricial ‚Äìpara rotar el texto‚Äì, es esencial encapsular esta parte del c√≥digo en un contexto `savedState()`
#### code-example ####
snippet: multi-ring-with-captions+es.py
----
image: 
----
diagram: 
#### text-block ####
content: Observa tambi√©n la forma en que organic√© los estilos de los diferentes elementos, los arcos y los subt√≠tulos. Escrib√≠ dos funciones separadas en las que agrup√© las funciones de propiedades (`font()`, `fill()`, `stroke()`, `strokeWidth()`) y defin√≠ algunos valores predeterminados en la interfaz de funci√≥n. De esta manera puedes verter algo de l√≥gica sin prohibir una aplicaci√≥n diferente.
#### text-block ####
content: En este punto, el programa est√° funcionando completamente, pero todav√≠a hay algunas cosas que se pueden mejorar. Son opcionales. Me gusta que mi c√≥digo, incluso los scripts simples como este, sea lo m√°s modular posible, lo que significa que me gustar√≠a encapsular la dona HSL en una funci√≥n para poder importarlo desde otro script de Python con bastante facilidad. De esta manera, tambi√©n me veo obligado a ser muy preciso en el manejo del espacio de nombres de la funci√≥n. La declaraci√≥n `Def` al rescate, que cualquier llamada de funci√≥n debe estar envuelta en una construcci√≥n condicional `if __name__ == "__main__":`. De esta manera, la dona se dibujar√° solo si el m√≥dulo se ejecuta expl√≠citamente, no si se importa. Por √∫ltimo, pero no menos importante, aseg√∫rate de que el script tenga un nombre que siga las reglas de identificaci√≥n.
#### text-block ####
content: Adem√°s, me gusta escribir ‚Äìy a menudo ejecutar‚Äì mis scripts desde fuera de la aplicaci√≥n Drawbot, para aprovechar las funciones IDE como el formateo de c√≥digo, los cursores m√∫ltiples y otras cosas que adoran los programadores. Por esta raz√≥n, tengo que importar expl√≠citamente cualquier funci√≥n de Drawbot que necesite en la parte superior del script. Adem√°s, el dibujo debe ser adoptado por las funciones `newDrawing()` y `endDrawing()` para iniciar la pila de dibujos y luego limpiarla. Guardar una imagen, especialmente si se recomienda iniciar el script desde la terminal; de lo contrario, no tendr√° ning√∫n comentario visual. Entonces, aqu√≠ puedes encontrar el resultado final.

#### code-example ####
snippet: HSLdonut+es.py
----
image: 
----
diagram: 
#### text-block ####
content: ¬øTienes curiosidad por saber c√≥mo hice las ilustraciones de los cilindros de colores? Import√© la funci√≥n hslDonut () de otro m√≥dulo y la llam√© varias veces con el siguiente script:
#### code-example ####
snippet: axonometry+es.py
----
image: 
----
diagram: 
---
hasTocNumber: yes
